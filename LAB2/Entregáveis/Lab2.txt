Aluno Wellington Bezerra - 1413383
Aluno Guilherme Marques - 1220676

QUESTÃO 1) Faça um programa para localizar determinado valor em um vetor de inteiros desordenado.
O programa deve ser composto por no mínimo 4 processos filhos,
em um mesmo nível, que devem ser responsáveis por procurar o valor em uma parte do vetor cada.
Ao encontrar o valor, o processo deve imprimir:

Filho <PID> Encontrou na posição # do vetor. Caso o processo não encontre, deve imprimir:
Filho <PID> Não encontrou ocorrência do valor. Explique o funcionamento do seu código.
-----------------------------------------------------
exercicio1.c

#include  <stdio.h>
#include  <string.h>
#include  <sys/types.h>
#include  <sys/wait.h>
#include <unistd.h>


void busca(int ini, int fim, int *vet, int elem){
	int i;
	for(i=ini; i<=fim; i++){
        if(vet[i] == elem){
			printf("achei no indice %d\n", i);
            printf("-------------\n");
            return;
        }
	}
	printf("nao achei\n");
    printf("-------------\n");
}

void childFunction(int i, int *vet, int elem){
    printf("Child : %d\n", getpid());
    // do stuff
	if (i == 0){
		busca(0, 2, vet, elem);
	}
	else {
		if(i == 1){
			busca(3, 5, vet, elem);
		}
		else {
			if (i == 2){
				busca(6, 8, vet, elem);
			}
			else {
				busca(9, 10, vet, elem);
			}
		}
	}
}

int main(){

    int vetor[10] = {3,5,7,2,8,4,1,2,6,5};
    int elem = 1;
    int childLimit = 4; // number of children wanted
    int childrenPids[childLimit]; // array to store children's PIDs if needed
    int currentPid, i;

    for(i=0; i<childLimit; i++){
        switch(currentPid = fork()){
            case 0:
                // in the child
                childFunction(i, vetor, elem);
                // exit the child normally and prevent the child
                // from iterating again
                return 0;
            case -1:
                printf("Error when forking\n");
                break;
            default:
                // in the father
                childrenPids[i] = currentPid; // store current child pid
                break;
        }

    }

    //wait for all child created to die
    waitpid(-1, NULL, 0);
}

-----------------------------------------------------
COMPILAÇÃO E EXECUÇÃO

$ gcc -o exer1 exer1.c
$ ./exer1
-----------------------------------------------------
RESULTADO

Child : 2469
nao achei
-------------
Child : 2470
nao achei
-------------
Child : 2471
achei no indice 6
-------------
Child : 2472
nao achei
-------------
-----------------------------------------------------
CONCLUSÃO

Por meio de um for, iteramos o números de filhos, ou processos que queremos criar.
A cada iteração é chamado o fork e é criado um processo filho.
No processo filho é chamada a função que busca, sendo passado para ela como parâmetros o valor procurado,
o indice inicial e final.
Após isso, caso o valor tenha sido achado, é impresso o índice do valor procurado e o processo que o achou,
se não, é impresso que o processo tal não acho o valor.
-----------------------------------------------------

QUESTÃO 2) Faça um programa que deve realizar a soma de 2 matrizes 3 X 3.
O programa deve ser estruturado em no mínimo 3 processos que fazem a soma de cada linha da matriz.
Cada processo exibe, ao terminar a soma, os valores para a linha da matriz.
Atenção para exibir as linhas na ordem correta.

Explique o funcionamento do seu código.
Explique como você controla a exibição de cada linha da matriz na ordem correta.
-----------------------------------------------------
exercicio2.c

#include  <stdio.h>
#include  <string.h>
#include  <sys/types.h>
#include  <sys/wait.h>
#include <unistd.h>

void childFunction(int pos, int matriz1[3][3], int matriz2[3][3]){
    printf("Child : %d\n", getpid());
	int j;
	int aux[3] = {0, 0, 0};
	for(j=0; j<3 ; j++){
		aux[j] = matriz1[pos][j] + matriz2[pos][j];
	}
	printf("linha %d: %d %d %d \n  ------ \n", pos, aux[0], aux[1], aux[2]);
	sleep(pos);
}

int main(){

    int matriz1[3][3] = {{1,2,3}, {4,5,6}, {7,8,9}};
    int matriz2[3][3] = {{1,2,3}, {4,5,6}, {7,8,9}};

    int childLimit = 3; /* numero de processos filho */
    int childrenPids[childLimit]; /* vetor que armazena PIDs dos processos filho */
    int currentPid, i;

    for(i=0; i<childLimit; i++){
        switch(currentPid = fork()){
            case 0:
                /* chama a função do processo filho */
                childFunction(i, matriz1, matriz2);
                /* fim do processo filho */
                return 0;
            case -1:
                printf("Error when forking\n");
                break;
            default:
                childrenPids[i] = currentPid; // store current child pid
                break;
        }

    }

    printf("Processo Pai : %d filhos criados\n", i);

    waitpid(-1, NULL, 0);
}

-----------------------------------------------------
COMPILAÇÃO E EXECUÇÃO

$ gcc -o exer2 exer2.c
$ ./exerc2
-----------------------------------------------------
RESULTADO

Processo Pai : 3 filhos criados
Child : 2614
linha 0: 2 4 6
  ------
Child : 2615
linha 1: 8 10 12
  ------
Child : 2616
linha 2: 14 16 18
  ------

-----------------------------------------------------
CONCLUSÃO2.

Por meio de um for, iteramos o números de filhos, ou processos que queremos criar.
A cada iteração é chamado o fork e é criado um processo filho.
No processo filho é chamada a função que soma as linhas das matrizes.
Após isso é impresso a soma resultante, o número da linha e
é chamado o sleep para garantir a ordem correta de impressão das linhas.

-----------------------------------------------------
QUESTÃO 3) Faça um programa que simule a SHELL, ou seja, o programa fica aguardando comandos, ao receber um comando,
o processo pai se duplica e designa a execução do comando ao filho.
Quando o filho acaba de executar, o pai volta a esperar um novo comando.

a) Teste para os seguintes comandos:
ls - Lista os arquivos/diretórios do diretório corrente
ps - exibe os processos que estão executando no momento pwd - exibe o diretório atual
O seu programa deve permitir a execução de comandos com argumentos.

b) Testeparaosseguintescomandos:
echo "Escreva uma mensagem aqui" - exibe a mensagem entre aspas
cat "nome de um arquivo" - exibe o contéudo do arquivo cujo nome é passado no parâmetro
grep "palavra" "nome de um arquivo" - exibe as ocorrências da palavra dentro do arquivo informado

c) Escreva um programa qualquer, compile-o e utilize o programa SHELL para executá-lo.
Explique o funcionamento do seu código.

-----------------------------------------------------
exercicio3.c

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>


int main(void){

    char *argv[100];
    char entrada[100];
    char raiz[100];

    int status;
    int index = 0;

    while(1){ /* loop da "shell" */

        strcpy(entrada, ""); /* limpa entrada */
        strcpy(raiz, ""); /* limpa a raiz */

        printf("Shell >> ");
        scanf("%[^\n]%*c", entrada); /* pega a entrada */

        if ( strcmp(entrada,"exit") == 0 ) { /* aborta o programa */
            return 0;
        }

        char *token;
        token = strtok(entrada," \""); /* pega a primeira parte da string */

        while(token != NULL) { /* preenche as posiçoes de argv */
            argv[index] = token;
            index = index + 1;
            token = strtok(NULL," \"");
        }

        argv[index] = NULL; /* NULL no final do vetor argv */
                        /* argv precisa ter NULL no final */


        if (fork() != 0){

            printf("\nProcesso do pai iniciado \n");
            waitpid(-1,&status,0);
            index = 0; /* reset do indice de argumentos */
            printf("Processo do pai finalizado \n");
        }
        else {
            printf("Processo do filho iniciado \n");
            printf("Raiz: %s\n", raiz);
            execvp(argv[0], argv); /* recebe um comando e os parametros desse comando  */
                                    /* argv[0] -> comando */
            printf("Processo do filho finalizado \n");
        }

    }

    return 0;
}
-----------------------------------------------------
test.txt

siscomp 1
sis
comp
siscomp 2
siscomp 3
comp
sis

-----------------------------------------------------
COMPILAÇÃO E EXECUÇÃO

$ gcc -o main main.c
$ ./main

-----------------------------------------------------
RESULTADO

a)

$ ls

Shell >> ls

Processo do pai iniciado
Processo do filho iniciado
Raiz:
Entregáveis	exer2.c		lab3		main		programa.c
exer1		lab2_1		lab3.c		main.c		test.txt
exer1.c		lab2_ex1.c	lab4		min
exer2		lab2_ex2.c	lab4.c		programa
Processo do pai finalizado

$ ps

Shell >> ps

Processo do pai iniciado
Processo do filho iniciado
Raiz:
  PID TTY           TIME CMD
 2301 ttys000    0:00.38 -bash
 2711 ttys000    0:00.00 ./main
Processo do pai finalizado

$ pwd

Processo do pai iniciado
Processo do filho iniciado
Raiz:
/Users/wellingtonbezerra/Desktop/2017.2/Sistemas de Computação/LAB2
Processo do pai finalizado

$ echo wellington bezerra

Shell >> echo wellington bezerra

Processo do pai iniciado
Processo do filho iniciado
Raiz:
wellington bezerra
Processo do pai finalizado

$ cat test.txt

Shell >> cat test.txt

Processo do pai iniciado
Processo do filho iniciado
Raiz:
siscomp 1
sis
comp
siscomp 2
siscomp 3
comp
sisProcesso do pai finalizado

$ grep siscomp test.txt

Shell >> grep siscomp test.txt

Processo do pai iniciado
Processo do filho iniciado
Raiz:
siscomp 1
siscomp 2
siscomp 3
Processo do pai finalizado

-----------------------------------------------------
CONCLUSÃO

Em um while sem parada, é printado "Shell >> " e esperado a entrada do usuário.
Após a entrada do usuário é checado se ele deseja sair da shell por meio da palavra 'exit'.
Então, é utilizado a função strtok que recebe uma string e um separador e
separa todas as sequências de caracteres entre o separador passado.
Com as tais sequências separadas, que nesse caso são os comandos e seus parâmetros,
cada uma delas é passada para um vetor de char.
Por fim, é gerado um processo filho que chama o execvp que com esse vetor
que na posição 0 está o comando e no resto os seus parâmetros, é executado o comando desejado.

-----------------------------------------------------
